<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Holly Polly — Змейка</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root{
    --page-bg: #ff4da6;
    --field-bg: #E1CCFB;
    --control-green: #2e8b57;
    --btn-color: #fff;
  }
  html,body{height:100dvh;margin:0;background:var(--page-bg);-webkit-text-size-adjust:100%;-webkit-touch-callout:none;font-family:"Futura","Trebuchet MS",Arial,sans-serif;overflow:hidden;}
  body{ display:flex; flex-direction:column; align-items:center; padding:12px; box-sizing:border-box; overscroll-behavior:contain; touch-action:none; }
  header{ text-align:center; margin-bottom:8px; user-select:none; color:#000; width:100% }
  header img{ max-height:84px; display:block; margin:0 auto; }
  header .slogan{ color:#000; margin-top:8px; font-weight:700; }
  #container{ background:var(--field-bg); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,0.25); position:relative; touch-action:none; }
  canvas{ display:block; image-rendering:optimizeQuality; touch-action:none; background:transparent; border-radius:12px; -webkit-user-select:none; user-select:none; }
  /* START overlay (tap to start) */
  #startOverlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; pointer-events:auto; }
  #startOverlay .msg{ padding:14px 18px; background:rgba(0,0,0,0.32); color:#fff; border-radius:12px; font-size:18px; text-align:center; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
  /* Game Over buttons — centered, stacked like старые версии */
  #gameOverButtons{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:70;
    display:none;
    flex-direction:column;
    gap:18px;
    align-items:center;
    pointer-events:auto;
  }
  .go-btn{
    background:var(--control-green);
    color:var(--btn-color);
    border:none;
    padding:14px 28px;
    border-radius:12px;
    font-size:20px;
    cursor:pointer;
    box-shadow:0 6px 12px rgba(0,0,0,0.18);
  }
  /* Leaderboard modal */
  .lb-modal{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:120; }
  .lb-modal[hidden]{ display:none; }
  .lb-card{ background:#fff; border-radius:14px; width:min(540px,94vw); box-shadow:0 10px 40px rgba(0,0,0,.35); padding:12px 14px; max-height:70vh; overflow:auto; }
  .lb-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .lb-head h3{ margin:0; font-size:18px; }
  .lb-close{ background:#eee; border:none; border-radius:8px; padding:6px 10px; cursor:pointer; }
  .lb-list{ margin:8px 0 0; padding:0 10px 8px; list-style:none; }
  .lb-item{ padding:8px; border-radius:8px; display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; }
  .lb-top5{ background:#fff8d6; }
  /* Loading overlay */
  #loadingOverlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9999; background:rgba(0,0,0,0.5); color:#fff; font-size:16px; gap:12px; flex-direction:column; }
  #loadingBar{ width:64%; max-width:420px; height:12px; background:rgba(255,255,255,0.15); border-radius:8px; overflow:hidden; }
  #loadingProgress{ height:100%; width:0%; background:linear-gradient(90deg,#fff 0,#ffd 60%); transition:width .18s ease; }
  @media (max-width:480px){
    .go-btn{ font-size:18px; padding:12px 22px; }
  }
</style>
</head>
<body>
  <header>
    <img src="logo.png" alt="logo" decoding="async">
    <div class="slogan">Holly Polly — твоя лучшая подруга!</div>
  </header>

  <div id="container" role="application" aria-label="Игра Змейка">
    <canvas id="game"></canvas>

    <!-- tap to start overlay -->
    <div id="startOverlay" aria-hidden="false">
      <div class="msg" id="startMsg">Загрузка...</div>
    </div>

    <!-- centered Game Over buttons (Заново + Таблица лидеров) -->
    <div id="gameOverButtons">
      <button id="btnRestart" class="go-btn">Заново</button>
      <button id="btnShare" class="go-btn">Таблица лидеров</button>
    </div>
  </div>

  <!-- Leaderboard modal -->
  <div id="leaderboardModal" class="lb-modal" hidden>
    <div class="lb-card">
      <div class="lb-head">
        <h3>Таблица лидеров</h3>
        <button id="lbClose" class="lb-close">✕</button>
      </div>
      <div id="lbLoading" style="display:none;margin-top:8px;">Загрузка...</div>
      <ol id="lbList" class="lb-list"></ol>
    </div>
  </div>

  <!-- Loading overlay (preload) -->
  <div id="loadingOverlay">
    <div id="loadingText">Загрузка ассетов... 0%</div>
    <div id="loadingBar"><div id="loadingProgress"></div></div>
    <div>
      <button id="retryAssets" style="display:none;padding:8px 12px;border-radius:8px;">Повторить</button>
    </div>
  </div>

<script>
/* ---------------- CONFIG ---------------- */
const LB_URL = 'https://script.google.com/macros/s/AKfycbwWwEFARyVpWEqLUcQ5FCAUUy6EDf8xXxVdC1FuyaYfGkySRK6e7Ryq_nM2X2RWn3YZ/exec';

const COLS = 12, ROWS = 22;
const BASE_STEP_MS = 120;
const START_SPEED_MULT = 1.30;
let stepDelay = Math.round(BASE_STEP_MS * START_SPEED_MULT);

const RENDER_SCALE = 1.2;
let DPR = 1;

const PARTICLE_SPEED_FACTOR = 0.32;
const PARTICLE_LIFE_BASE = 48;
const PARTICLE_LIFE_RAND = 48;
const PARTICLE_LIFE_FACTOR = 1.6;

const FOOD_SCALE = 2.42;
const MAX_OVERFLOW_PCT = 0.65;
const MAX_OVERFLOW_TILES = 0.9;
const HEARTS_BASE = 12;
const HEARTS_COUNT = Math.max(1, Math.round(HEARTS_BASE * 0.6));
const SPEED_MULT_BASE = 0.975;
const EXTRA_STEP_PCT = 0.003;
const SPEED_MULT_COMBINED = SPEED_MULT_BASE - EXTRA_STEP_PCT;
const MIN_STEP = 25;
const SMOOTH_LERP = 0.14;

/* ---------------- DOM ---------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:true });
const container = document.getElementById('container');
const startOverlay = document.getElementById('startOverlay');
const startMsg = document.getElementById('startMsg');
const gameOverButtons = document.getElementById('gameOverButtons');
const btnRestart = document.getElementById('btnRestart');
const btnShare = document.getElementById('btnShare');

const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');
const loadingProgress = document.getElementById('loadingProgress');
const retryAssets = document.getElementById('retryAssets');

const lbModal = document.getElementById('leaderboardModal');
const lbList = document.getElementById('lbList');
const lbClose = document.getElementById('lbClose');
const lbLoading = document.getElementById('lbLoading');

/* ---------------- Assets list ---------------- */
const categoryConfig = {
  balzam:   {prefix:'balzam',    count:8,  points:50,  w:1, h:1, weight: 1},
  cream:    {prefix:'Cream',     count:3,  points:100, w:1, h:2, weight: 1},
  shampoo:  {prefix:'Shampoo',   count:3,  points:150, w:1, h:2, weight: 1},
  tip:      {prefix:'tip',       count:2,  points:200, w:1, h:2, weight: 0.35}
};
const hairsprayConfig = { prefix:'HairSpray', count:3, points:300, w:1, h:2 };

const STATIC_ASSETS = [
  {key:'golova', url:'golova.png'},
  {key:'telo1', url:'telo1.png'},
  {key:'telo2', url:'telo2.png'},
  {key:'flower', url:'flower.png'}
];
const ASSET_LIST = STATIC_ASSETS.slice();
for (const k in categoryConfig){
  const cfg = categoryConfig[k];
  for (let i=1;i<=cfg.count;i++) ASSET_LIST.push({ key: `${k}${i}`, url: `assets/${cfg.prefix}${i}.png` });
}
for (let i=1;i<=hairsprayConfig.count;i++) ASSET_LIST.push({ key: `hairspray${i}`, url: `assets/${hairsprayConfig.prefix}${i}.png` });

/* ---------------- State ---------------- */
let imagesByCategory = {};
let hairsprayImages = [];
let headImg=null, bodyImg=null, tailImg=null, flowerImg=null;
let tileSize=40, canvasW=0, canvasH=0;
let snake=[], dx=1, dy=0;
let food=null, extraFood=null, particles=[];
let gameOver=false, timerId=null;
let eatenSinceSpeedup=0, totalEaten=0, scoreVar=0, globalTime=0;
let pendingHairspray=false;
let gameStarted=false;

/* ---------------- Preload helpers ---------------- */
function loadImageWithTimeout(url, timeoutMs = 9000, tries = 2){
  return new Promise(async (resolve, reject) => {
    for (let attempt=1; attempt<=tries; attempt++){
      try{
        const img = new Image();
        img.decoding = 'async';
        img.loading = 'eager';
        const p = new Promise((res, rej) => { img.onload = () => res(img); img.onerror = () => rej(new Error('load error ' + url)); });
        img.src = url;
        if (img.decode){
          await Promise.race([ img.decode(), new Promise((_, r)=>setTimeout(()=>r(new Error('decode timeout')), timeoutMs)) ]);
          return resolve(img);
        } else {
          const loaded = await Promise.race([ p, new Promise((_, r)=>setTimeout(()=>r(new Error('load timeout')), timeoutMs)) ]);
          return resolve(loaded);
        }
      } catch(err){
        console.warn('Asset load failed', url, 'attempt', attempt, err);
        if (attempt === tries) return reject(err);
        await new Promise(r => setTimeout(r, 300 + Math.random()*200));
      }
    }
  });
}

async function preloadAllAssets(list, onProgress){
  const images = {};
  let loaded = 0;
  for (const item of list){
    try{
      const img = await loadImageWithTimeout(item.url, 9000, 2);
      images[item.key] = img;
      loaded++;
      if (onProgress) onProgress(loaded, list.length, item.key, item.url);
    } catch(err){
      throw new Error('Failed to load ' + item.url + ' — ' + err.message);
    }
  }
  return images;
}

/* ---------------- Flowers setup (50% fewer) ---------------- */
let flowerCells = null;
function generateDefaultFlowerCells(){
  const totalCells = COLS * ROWS;
  const desired = Math.max(1, Math.round(totalCells * 0.125)); // ~12.5% (previously ~25% -> now 50% less)
  const set = new Set();
  let i = 0;
  while(set.size < desired && i < totalCells * 8){
    // simple pseudo random but deterministic-ish
    const rx = Math.floor(((Math.sin(i*777 + 13) + 1) / 2) * COLS);
    const ry = Math.floor(((Math.cos(i*131 + 7) + 1) / 2) * ROWS);
    set.add(`${Math.max(0, Math.min(COLS-1, rx))},${Math.max(0, Math.min(ROWS-1, ry))}`);
    i++;
  }
  return Array.from(set).map(s => s.split(',').map(Number));
}
function useFlowerCellsFromWindowOrDefault(){
  if (Array.isArray(window._FLOWER_CELLS) && window._FLOWER_CELLS.length){
    const uniq = new Set();
    flowerCells = window._FLOWER_CELLS.map(c => [Number(c[0]), Number(c[1])]).filter(c => c[0]>=0 && c[0]<COLS && c[1]>=0 && c[1]<ROWS).filter(c=>{
      const k = `${c[0]},${c[1]}`; if (uniq.has(k)) return false; uniq.add(k); return true;
    });
  } else {
    flowerCells = generateDefaultFlowerCells();
  }
}

/* ---------------- Layout & canvas ---------------- */
function fitLayout(){
  const vw = window.innerWidth;
  const vh = Math.min(window.visualViewport?.height || window.innerHeight, document.documentElement.clientHeight || window.innerHeight);
  const headerH = document.querySelector('header')?.getBoundingClientRect().height || 0;
  const EXTRA_BOTTOM = 18;
  const maxW = Math.min(vw - 32, 960);
  const sizeByW = Math.floor(maxW / COLS);
  const freeH = vh - headerH - EXTRA_BOTTOM;
  const sizeByH = Math.floor(freeH / ROWS);
  tileSize = Math.max(12, Math.min(sizeByW, sizeByH));
}

function resizeCanvas(){
  fitLayout();
  const cssW = tileSize * COLS;
  const cssH = tileSize * ROWS;
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  container.style.width = cssW + 'px';
  container.style.height = cssH + 'px';
  const device = Math.max(1, window.devicePixelRatio || 1);
  DPR = Math.min(1.6, device * RENDER_SCALE);
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  canvasW = cssW;
  canvasH = cssH;
}
window.addEventListener('resize', ()=>{ resizeCanvas(); });
window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ resizeCanvas(); }, 120); });

/* ---------------- Drawing helpers ---------------- */
function drawEllipseFilled(cx, cy, rx, ry, fillStyle, alpha=1, rotation=0){
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(rotation); ctx.globalAlpha = alpha; ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fillStyle = fillStyle; ctx.fill(); ctx.restore();
}
function computeImageDrawRect(areaLeft, areaTop, areaW, areaH){
  const desiredW = Math.round(areaW * FOOD_SCALE);
  const desiredH = Math.round(areaH * FOOD_SCALE);
  const allowedOverflowW = Math.min(Math.round(areaW * MAX_OVERFLOW_PCT), Math.round(tileSize * MAX_OVERFLOW_TILES));
  const allowedOverflowH = Math.min(Math.round(areaH * MAX_OVERFLOW_PCT), Math.round(tileSize * MAX_OVERFLOW_TILES));
  const maxAllowedW = areaW + allowedOverflowW;
  const maxAllowedH = areaH + allowedOverflowH;
  let drawW = Math.min(desiredW, maxAllowedW);
  let drawH = Math.min(desiredH, maxAllowedH);
  return { drawW, drawH, areaLeft, areaTop, areaW, areaH, maxAllowedW, maxAllowedH };
}

/* ---------------- Draw flowers only in specified cells (smaller size) ---------------- */
function drawFlowers(){
  if (!flowerImg || !flowerImg.complete || !flowerImg.naturalWidth) return;
  if (!Array.isArray(flowerCells) || !flowerCells.length) return;
  ctx.save();
  ctx.globalAlpha = 0.88;
  const size = Math.max(6, Math.floor(tileSize * 0.6)); // reduced size -> prevents overlap
  for (const [cxCell, cyCell] of flowerCells){
    const cx = (cxCell + 0.5) * tileSize;
    const cy = (cyCell + 0.5) * tileSize;
    ctx.drawImage(flowerImg, Math.round(cx - size/2), Math.round(cy - size/2), size, size);
  }
  ctx.restore();
}

/* ---------------- Food drawing ---------------- */
function drawSingleFood(it, nowSec){
  if (!it) return;
  const cellsW = it.w, cellsH = it.h;
  const areaW = tileSize * cellsW;
  const areaH = tileSize * cellsH;
  const areaLeft = it.x * tileSize;
  const areaTop  = it.y * tileSize;
  if (it.cat === 'hairspray'){
    const pulse = 1 + 0.24 * Math.sin(nowSec * 4 + it.x * 1.7 + it.y * 0.9);
    const cx = Math.round(areaLeft + areaW/2);
    const cy = Math.round(areaTop + areaH/2);
    const base = Math.min(areaW, areaH);
    const ry = Math.max(12, Math.round((base/1.8 + 16) * pulse));
    const rx = Math.max(7, Math.round((base/3.2 + 6) * pulse));
    drawEllipseFilled(cx, cy, rx, ry, 'rgba(255,235,0,0.98)', 0.98);
  }
  if (it.img && it.img.complete && it.img.naturalWidth && it.img.naturalHeight){
    const c = computeImageDrawRect(areaLeft, areaTop, areaW, areaH);
    const iw = it.img.naturalWidth, ih = it.img.naturalHeight;
    const aspect = iw / ih;
    let drawW = c.drawW;
    let drawH = Math.round(drawW / aspect);
    if (drawH > c.maxAllowedH){ drawH = c.maxAllowedH; drawW = Math.round(drawH * aspect); }
    const drawX = Math.round(areaLeft + (areaW - drawW)/2);
    const drawY = Math.round(areaTop + (areaH - drawH)/2);
    ctx.drawImage(it.img, drawX, drawY, drawW, drawH);
  } else {
    const c = computeImageDrawRect(areaLeft, areaTop, areaW, areaH);
    const dw = Math.round(Math.min(c.drawW, c.maxAllowedW * 0.95));
    const dh = Math.round(dw / 1.2);
    const dx = Math.round(areaLeft + (areaW - dw)/2);
    const dy = Math.round(areaTop + (areaH - dh)/2);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(dx, dy, dw, dh);
  }
}
function drawFood(nowSec){ drawSingleFood(food, nowSec); if (extraFood) drawSingleFood(extraFood, nowSec); }

/* ---------------- Snake drawing ---------------- */
function drawSnake(){
  for (let i=0;i<snake.length;i++){
    const s = snake[i];
    const targetCx = s.x * tileSize + tileSize/2;
    const targetCy = s.y * tileSize + tileSize/2;
    s.px = lerp(s.px, targetCx, SMOOTH_LERP);
    s.py = lerp(s.py, targetCy, SMOOTH_LERP);
  }
  for (let i=1;i<snake.length;i++){
    const s = snake[i];
    const size = Math.max(6, Math.floor(tileSize * 1.06));
    if (i === snake.length - 1){
      if (tailImg && tailImg.complete && tailImg.naturalWidth){
        const tail = snake[snake.length - 1];
        const prev = snake[snake.length - 2];
        const angle = Math.atan2(prev.py - tail.py, prev.px - tail.px);
        ctx.save(); ctx.translate(tail.px, tail.py); ctx.rotate(angle + Math.PI/2);
        let iw = tailImg.naturalWidth, ih = tailImg.naturalHeight; let aspect = iw/ih;
        let dw = size, dh = size; if (dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect);
        ctx.drawImage(tailImg, -dw/2, -dh/2, dw, dh); ctx.restore();
      } else { ctx.fillStyle = '#E159A9'; ctx.beginPath(); ctx.arc(s.px, s.py, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill(); }
    } else {
      if (bodyImg && bodyImg.complete && bodyImg.naturalWidth){
        const prev = snake[i-1]; const next = snake[i+1] || snake[i];
        const angle = Math.atan2(next.py - prev.py, next.px - prev.px);
        ctx.save(); ctx.translate(s.px, s.py); ctx.rotate(angle + Math.PI/2);
        let iw = bodyImg.naturalWidth, ih = bodyImg.naturalHeight; let aspect = iw/ih;
        let dw = size, dh = size; if (dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect);
        ctx.drawImage(bodyImg, -dw/2, -dh/2, dw, dh); ctx.restore();
      } else { ctx.fillStyle = '#E159A9'; ctx.beginPath(); ctx.arc(s.px, s.py, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill(); }
    }
  }
  const head = snake[0];
  const hx = head.px, hy = head.py;
  const headScale = 1.42;
  const headSizeBase = Math.max(6, Math.floor(tileSize * headScale));
  if (headImg && headImg.complete && headImg.naturalWidth){
    const dirAngle = Math.atan2(dy, dx);
    ctx.save(); ctx.translate(hx, hy); ctx.rotate(dirAngle + Math.PI/2);
    let iw = headImg.naturalWidth, ih = headImg.naturalHeight; let aspect = iw/ih;
    let dw = headSizeBase, dh = headSizeBase; if (dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect);
    ctx.drawImage(headImg, -dw/2, -dh/2, dw, dh); ctx.restore();
  } else {
    ctx.fillStyle = '#E159A9'; ctx.beginPath(); ctx.arc(hx, hy, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill();
    const eyeR = Math.max(2, Math.floor(tileSize/6));
    const eyeOffsetX = tileSize / 4, eyeOffsetY = tileSize / 6;
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(hx - eyeOffsetX, hy - eyeOffsetY, eyeR, 0, Math.PI*2); ctx.arc(hx + eyeOffsetX, hy - eyeOffsetY, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(hx - eyeOffsetX, hy - eyeOffsetY, Math.max(1, Math.floor(eyeR/2)), 0, Math.PI*2); ctx.arc(hx + eyeOffsetX, hy - eyeOffsetY, Math.max(1, Math.floor(eyeR/2)), 0, Math.PI*2); ctx.fill();
  }
}

/* ---------------- Particles ---------------- */
function spawnParticlesAt(cellX, cellY, cellsW, cellsH, cat){
  const cx = (cellX + cellsW/2) * tileSize;
  const cy = (cellY + cellsH/2) * tileSize;
  const char = (cat === 'hairspray') ? '⭐️' : '❤️';
  const SLOW_MULT = PARTICLE_SPEED_FACTOR;
  const LIFE_BASE = PARTICLE_LIFE_BASE;
  const LIFE_RAND = PARTICLE_LIFE_RAND;
  const LIFE_FACTOR = PARTICLE_LIFE_FACTOR;
  const count = Math.max(3, Math.min(6, Math.floor(HEARTS_COUNT * 0.8)));
  for (let i=0;i<count;i++){
    const angle = Math.random() * Math.PI * 2;
    const baseSpeed = 0.5 + Math.random() * 1.0;
    const vyBias = (cat === 'hairspray') ? -0.35 - Math.random()*0.15 : (Math.random()*0.3 - 0.15);
    const life = Math.round((LIFE_BASE + Math.floor(Math.random()*LIFE_RAND)) * LIFE_FACTOR);
    const size = tileSize * (0.45 + Math.random() * 0.6);
    const vx = Math.cos(angle) * baseSpeed * (0.5 + Math.random()*0.7) * SLOW_MULT;
    const vy = (Math.sin(angle) * baseSpeed * (0.5 + Math.random()*0.7) + vyBias) * SLOW_MULT;
    particles.push({ type:'emoji', char, x: cx + (Math.random()-0.5) * tileSize * 0.2, y: cy + (Math.random()-0.5) * tileSize * 0.2, vx, vy, size, life, maxLife: life });
  }
}
function updateParticles(){
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.994; p.vy += 0.006;
    p.life--;
    if (p.life <= 0 || p.x < -50 || p.x > canvasW + 50 || p.y < -50 || p.y > canvasH + 50) particles.splice(i,1);
  }
}
function drawParticles(){
  if (!particles.length) return;
  ctx.save();
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    if (p.type === 'emoji'){
      ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
      ctx.font = `${Math.max(8, Math.floor(p.size))}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.char, Math.round(p.x), Math.round(p.y));
      ctx.globalAlpha = 1;
    } else {
      ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
      ctx.fillStyle = p.color || '#fff'; ctx.beginPath(); ctx.arc(Math.round(p.x), Math.round(p.y), p.r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
  }
  ctx.restore();
}

/* ---------------- Score draw ---------------- */
function drawScore(){
  ctx.save();
  ctx.fillStyle = '#000';
  ctx.font = `${Math.max(14, Math.floor(tileSize * 0.7))}px Futura, Arial, sans-serif`;
  ctx.textBaseline = 'top';
  ctx.fillText('Счёт: ' + scoreVar, Math.max(6, tileSize*0.15), Math.max(6, tileSize*0.12));
  ctx.restore();
}

/* ---------------- Render loop ---------------- */
function renderLoop(ts){
  globalTime = ts / 1000;
  if (extraFood && performance.now() > extraFood.expiresAt) extraFood = null;
  ctx.clearRect(0,0,canvasW,canvasH);
  drawFlowers();
  drawFood(globalTime);
  drawSnake();
  drawParticles();
  drawScore();
  updateParticles();
  requestAnimationFrame(renderLoop);
}

/* ---------------- Utils ---------------- */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function pointOnSnake(x,y){ return snake.some(s => s.x===x && s.y===y); }
function rectFree(x,y,w,h){ if (x<0||y<0||x+w>COLS||y+h>ROWS) return false; for (let sx=x;sx<x+w;sx++) for (let sy=y;sy<y+h;sy++) if(pointOnSnake(sx,sy)) return false; return true; }
function lerp(a,b,t){ return a + (b-a) * t; }
function chooseCategory(){ const keys=Object.keys(categoryConfig); const pool=[]; for(const k of keys){ const w = categoryConfig[k].weight; const times=Math.max(1,Math.round(w*10)); for(let i=0;i<times;i++) pool.push(k); } return pool[randInt(0,pool.length-1)]; }

/* ---------------- Food placement ---------------- */
function placeFood(){
  const maxAttempts = 1000; let attempts=0; food=null;
  while(attempts++ < maxAttempts){
    const cat = chooseCategory(); const cfg = categoryConfig[cat];
    const w=cfg.w, h=cfg.h; const x=randInt(0, COLS-w); const y=randInt(0, ROWS-h);
    if (!rectFree(x,y,w,h)) continue;
    const imgs = imagesByCategory[cat] || []; const img = imgs.length ? imgs[randInt(0, imgs.length-1)] : null;
    food = { x, y, cat, img, points: cfg.points, w, h };
    break;
  }
  if (!food){
    outer: for (let yy=0; yy<ROWS; yy++) for (let xx=0; xx<COLS; xx++) if (!pointOnSnake(xx,yy)){ const imgs = imagesByCategory['balzam']||[]; food={ x:xx,y:yy,cat:'balzam',img:imgs[0]||null,points:50,w:1,h:1 }; break outer; }
  }
  if (pendingHairspray){
    const wH = hairsprayConfig.w, hH = hairsprayConfig.h; let placed=false, attempts2=0;
    while(attempts2++<800 && !placed){
      const x = randInt(0, COLS-wH); const y = randInt(0, ROWS-hH);
      if (!rectFree(x,y,wH,hH)) continue;
      if (!(x + wH <= food.x || x >= food.x + food.w || y + hH <= food.y || y >= food.y + food.h)) continue;
      const img = hairsprayImages.length ? hairsprayImages[randInt(0, hairsprayImages.length-1)] : null;
      extraFood = { x, y, cat:'hairspray', img, points: hairsprayConfig.points, w: wH, h: hH, expiresAt: performance.now() + 3000 };
      placed = true;
    }
    pendingHairspray = false;
  }
}

/* ---------------- Segments ---------------- */
function createSegment(x,y){ return { x, y, px: x*tileSize + tileSize/2, py: y*tileSize + tileSize/2 }; }

/* ---------------- Init / restart ---------------- */
function initGame(){
  resizeCanvas();
  useFlowerCellsFromWindowOrDefault();
  const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
  snake = [ createSegment(cx,cy), createSegment(cx-1,cy), createSegment(cx-2,cy) ];
  dx=1; dy=0; stepDelay = Math.round(BASE_STEP_MS * START_SPEED_MULT);
  food=null; extraFood=null; pendingHairspray=false; particles=[]; gameOver=false;
  eatenSinceSpeedup=0; totalEaten=0; scoreVar=0;
  placeFood();
  gameOverButtons.style.display = 'none';
  startOverlay.style.display = 'flex';
  startOverlay.setAttribute('aria-hidden','false');
  startMsg.textContent = 'Тапни, чтобы начать';
  gameStarted = false;
  if (timerId){ clearTimeout(timerId); timerId=null; }
  requestAnimationFrame(renderLoop);
}

/* ---------------- Step logic ---------------- */
function willCollide(nx, ny){
  if (nx<0 || ny<0 || nx>=COLS || ny>=ROWS) return true;
  for (let i=1;i<snake.length;i++) if (snake[i].x===nx && snake[i].y===ny) return true;
  return false;
}

async function onGameOver(){
  gameOver = true;
  try{ await sendScoreToSheets({ username: getTgUsername()||'Игрок', score: scoreVar, tg_id: getTgId()||'' }); } catch(e){ console.warn('sendScore err', e); }
  // show centered GO buttons and hide start overlay
  gameOverButtons.style.display = 'flex';
  startOverlay.style.display = 'none';
  startOverlay.setAttribute('aria-hidden','true');
  gameStarted = false;
  if (timerId){ clearTimeout(timerId); timerId = null; }
}

function performStep(){
  if (gameOver || !gameStarted) return;
  const headGX = snake[0].x + dx, headGY = snake[0].y + dy;
  if (willCollide(headGX, headGY)){ onGameOver(); return; }
  snake.unshift(createSegment(headGX, headGY));
  let ateExtra = false;
  if (extraFood){
    if (headGX >= extraFood.x && headGX < extraFood.x + extraFood.w && headGY >= extraFood.y && headGY < extraFood.y + extraFood.h){
      scoreVar += extraFood.points; totalEaten++; eatenSinceSpeedup++; spawnParticlesAt(extraFood.x, extraFood.y, extraFood.w, extraFood.h, 'hairspray'); extraFood = null; ateExtra = true;
    }
  }
  if (food && !ateExtra){
    if (headGX >= food.x && headGX < food.x + food.w && headGY >= food.y && headGY < food.y + food.h){
      totalEaten++; eatenSinceSpeedup++; scoreVar += food.points; spawnParticlesAt(food.x, food.y, food.w, food.h, food.cat); pendingHairspray=(Math.random()<0.10); placeFood();
    }
  }
  if (!ateExtra && !(food && headGX >= food.x && headGX < food.x + food.w && headGY >= food.y && headGY < food.y + food.h)) snake.pop();
  if (eatenSinceSpeedup >= 3){ stepDelay = Math.max(MIN_STEP, Math.round(stepDelay * SPEED_MULT_COMBINED)); eatenSinceSpeedup = 0; }
  if (extraFood && performance.now() > extraFood.expiresAt) extraFood = null;
  scheduleNextStep();
}
function scheduleNextStep(){ if (timerId) clearTimeout(timerId); timerId = setTimeout(performStep, stepDelay); }

/* ---------------- Input: keyboard + touch + start by tap ---------------- */
function setDir(nx, ny){ if (nx === -dx && ny === -dy) return; dx = nx; dy = ny; }
window.addEventListener('keydown', e=>{
  if (e.key === 'ArrowUp') setDir(0,-1);
  else if (e.key === 'ArrowDown') setDir(0,1);
  else if (e.key === 'ArrowLeft') setDir(-1,0);
  else if (e.key === 'ArrowRight') setDir(1,0);
});

let tsx=0, tsy=0, swiping=false;
canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; tsx=t.clientX; tsy=t.clientY; swiping=true; if (!gameStarted && !gameOver){ startGame(); } }, {passive:true});
canvas.addEventListener('touchmove', e=>{ if (!swiping) return; const t=e.touches[0]; const dxs=t.clientX-tsx, dys=t.clientY-tsy; const TH=Math.max(20, tileSize*0.2); if (Math.abs(dxs)<TH && Math.abs(dys)<TH) return; if (Math.abs(dxs)>Math.abs(dys)){ if (dxs>0) setDir(1,0); else setDir(-1,0); } else { if (dys>0) setDir(0,1); else setDir(0,-1); } swiping=false; }, {passive:true});
canvas.addEventListener('touchend', e=>{ swiping=false; }, {passive:true});

startOverlay.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if (!gameStarted) startGame(); });
canvas.addEventListener('pointerdown', (e)=>{ if (!gameStarted && !gameOver){ startGame(); } });

function startGame(){
  if (gameStarted) return;
  gameStarted = true; gameOver = false;
  startOverlay.style.display = 'none';
  startOverlay.setAttribute('aria-hidden','true');
  gameOverButtons.style.display = 'none';
  if (timerId) clearTimeout(timerId);
  timerId = setTimeout(performStep, stepDelay);
  requestAnimationFrame(renderLoop);
}

/* ---------------- Leaderboard / GAS ---------------- */
async function sendScoreToSheets({username, score, tg_id}){
  const payload = { username, score: String(score), tg_id };
  try{
    if (navigator.sendBeacon){
      const blob = new Blob([JSON.stringify(payload)], { type:'application/json' });
      const ok = navigator.sendBeacon(LB_URL, blob);
      if (ok) return {ok:true, via:'beacon'};
    }
  } catch(e){}
  try{
    await fetch(LB_URL, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    return {ok:true, via:'no-cors'};
  } catch(e){
    try{
      const res = await fetch(LB_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      return {ok:res.ok};
    } catch(err){ return {ok:false, error:String(err)}; }
  }
}

async function getTopFromSheets(){
  const res = await fetch(LB_URL);
  if (!res.ok) throw new Error('LB fetch failed');
  return res.json();
}

btnRestart.addEventListener('click', ()=>{ initGame(); });
btnShare.addEventListener('click', async ()=>{ 
  lbList.innerHTML=''; lbLoading.style.display='block'; lbModal.hidden=false;
  try{
    const data = await getTopFromSheets();
    const top = (data.top || []).slice(0,10);
    lbList.innerHTML='';
    top.forEach((row, idx)=>{
      const li = document.createElement('li'); li.className = 'lb-item';
      if (idx < 5) li.classList.add('lb-top5');
      const name = row.username || 'Игрок';
      const score = row.score || 0;
      li.innerHTML = `<div style="display:flex;justify-content:space-between;gap:12px;"><span>#${idx+1} ${name}</span><strong>${score}</strong></div>`;
      lbList.appendChild(li);
    });
  } catch(e){
    lbList.innerHTML = '<li style="padding:8px;color:#a00">Не удалось загрузить таблицу лидеров.</li>';
    console.warn(e);
  } finally{
    lbLoading.style.display='none';
  }
});
lbClose.addEventListener('click', ()=>{ lbModal.hidden=true; });

/* ---------------- Boot sequence ---------------- */
async function boot(){
  loadingOverlay.style.display = 'flex';
  loadingText.textContent = 'Загрузка ассетов... 0%';
  loadingProgress.style.width = '0%';
  retryAssets.style.display = 'none';
  try{
    const imgs = await preloadAllAssets(ASSET_LIST, (loaded, total)=>{
      const pct = Math.round(loaded/total*100);
      loadingText.textContent = `Загрузка ассетов... ${pct}% (${loaded}/${total})`;
      loadingProgress.style.width = `${pct}%`;
    });
    imagesByCategory = {};
    for (const k in categoryConfig) imagesByCategory[k] = [];
    hairsprayImages = [];
    for (const k in imgs){
      if (k.startsWith('balzam')) imagesByCategory['balzam'].push(imgs[k]);
      else if (k.startsWith('Cream')) imagesByCategory['cream'].push(imgs[k]);
      else if (k.startsWith('Shampoo')) imagesByCategory['shampoo'].push(imgs[k]);
      else if (k.startsWith('tip')) imagesByCategory['tip'].push(imgs[k]);
      else if (k.startsWith('hairspray')) hairsprayImages.push(imgs[k]);
    }
    headImg = imgs['golova'] || null;
    bodyImg = imgs['telo1'] || null;
    tailImg = imgs['telo2'] || null;
    flowerImg = imgs['flower'] || null;
    loadingOverlay.style.display = 'none';
    initGame();
  } catch(err){
    console.error('Preload failed', err);
    loadingText.textContent = 'Ошибка загрузки ассетов. Проверь пути и сеть.';
    retryAssets.style.display = 'inline-block';
    retryAssets.onclick = () => { boot(); };
  }
}

/* ---------------- Helpers for Telegram user info (used when sending score) ---------------- */
(function tgReady(){ try{ if (Telegram?.WebApp){ Telegram.WebApp.ready(); Telegram.WebApp.expand?.(); } }catch(e){} })();
function getTgUser(){ const u = Telegram?.WebApp?.initDataUnsafe?.user; return u || null; }
function getTgId(){ const u = getTgUser(); return u?.id ? String(u.id) : ''; }
function getTgUsername(){ const u = getTgUser(); if (!u) return ''; if (u.username) return '@'+u.username; const fn = u.first_name||'', ln = u.last_name||''; const combo = (fn + ' ' + ln).trim(); return combo || 'Игрок'; }

/* ---------------- Expose debug helpers ---------------- */
window._hp = { initGame, startGame, setFlowerCells(cells){ window._FLOWER_CELLS = cells; useFlowerCellsFromWindowOrDefault(); }, getState(){ return { tileSize, COLS, ROWS, canvasW, canvasH, gameStarted, gameOver, scoreVar }; } };

/* ---------------- Start ---------------- */
resizeCanvas();
boot();

</script>
</body>
</html>
