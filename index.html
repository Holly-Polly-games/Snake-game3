<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Holly Polly — Змейка</title>
<style>
  :root{
    --page-bg:#FF007F;
    --field-bg:#E1CCFB;
    --control-green:#2e8b57;
  }
  html,body{height:100%;margin:0;}
  body{
    background:var(--page-bg);
    display:flex;
    flex-direction:column;
    align-items:center;
    font-family:"Futura","Trebuchet MS",Arial,sans-serif;
    padding:12px;
    box-sizing:border-box;
  }

  header{ text-align:center; margin-bottom:8px; }
  header img{ max-height:84px; display:block; margin:0 auto; }
  header .slogan{ color:#000; margin-top:8px; font-weight:700; }

  #container{
    background:var(--field-bg);
    border-radius:14px;
    box-shadow:0 10px 30px rgba(0,0,0,0.25);
    position:relative;
  }

  canvas{ display:block; image-rendering: optimizeQuality; }

  .overlay-btn{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    background:var(--control-green);
    color:#fff;
    border:none;
    padding:12px 22px;
    border-radius:10px;
    font-size:18px;
    display:none;
    z-index:20;
    cursor:pointer;
  }
  #btnRestart{ top:42%; }
  #btnShare{ top:56%; }

  #controls{
    margin-top:10px;
    display:grid;
    grid-template-areas:
      ". up ."
      "left . right"
      ". down .";
    gap:8px;
  }
  .ctrl-btn{ width:64px; height:64px; border-radius:999px; background:var(--control-green); color:#fff; border:none; font-size:22px; cursor:pointer; }
  @media(max-width:480px){ .ctrl-btn{ width:54px; height:54px; font-size:18px; } }

  /* ===== ЛИДЕРБОРД (модалка) ===== */
  .lb-modal{ position:fixed; inset:0; background:rgba(0,0,0,.5);
    display:flex; align-items:center; justify-content:center; z-index:50; }
  .lb-modal[hidden]{ display:none; }
  .lb-card{ background:#fff; border-radius:14px; width:min(520px,92vw);
    box-shadow:0 10px 40px rgba(0,0,0,.35); padding:14px 16px; }
  .lb-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .lb-head h3{ margin:0; font-size:20px; }
  .lb-close{ background:#eee; border:none; border-radius:8px; padding:6px 10px; cursor:pointer; }
  .lb-list{ margin:8px 0 0; padding:0 18px 12px; max-height:60vh; overflow:auto; }
  .lb-item-me{ background:#FFEBF7; border-radius:10px; padding:4px 8px; }

  /* ==== DEBUG overlay (встроенная диагностика) ==== */
  #debugOverlay{
    position:fixed;left:8px;right:8px;bottom:8px;z-index:9999;
    background:rgba(0,0,0,.75);color:#fff;padding:10px 12px;border-radius:12px;
    font:12px/1.4 system-ui,-apple-system,Arial; display:none;
  }
  #debugOverlay button{ padding:4px 8px; border-radius:8px; border:none; cursor:pointer; }
</style>
</head>
<body>
  <header>
    <img src="logo.png" alt="logo">
    <div class="slogan">Holly Polly — твоя лучшая подруга!</div>
  </header>

  <div id="container">
    <canvas id="game"></canvas>
    <button id="btnRestart" class="overlay-btn">Заново</button>
    <button id="btnShare" class="overlay-btn">Таблица лидеров</button>
  </div>

  <!-- ===== ЛИДЕРБОРД: модалка ===== -->
  <div id="leaderboardModal" class="lb-modal" hidden>
    <div class="lb-card">
      <div class="lb-head">
        <h3>Таблица лидеров</h3>
        <button id="lbClose" class="lb-close">✕</button>
      </div>
      <ol id="lbList" class="lb-list"></ol>
    </div>
  </div>

  <div id="controls">
    <div></div>
    <button class="ctrl-btn" id="btnUp">↑</button>
    <div></div>

    <button class="ctrl-btn" id="btnLeft">←</button>
    <div></div>
    <button class="ctrl-btn" id="btnRight">→</button>

    <div></div>
    <button class="ctrl-btn" id="btnDown">↓</button>
    <div></div>
  </div>

  <!-- ==== DEBUG overlay UI ==== -->
  <div id="debugOverlay">
    <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;">
      <strong>DEBUG</strong>
      <div>
        <button id="dbgSend" style="margin-right:6px;">Тест POST</button>
        <button id="dbgHide">Скрыть</button>
      </div>
    </div>
    <pre id="dbgText" style="white-space:pre-wrap;margin:8px 0 0;max-height:32vh;overflow:auto"></pre>
  </div>

<script>
/* ========== CONFIG ========== */
const COLS = 12;
const ROWS = 22;
const BASE_STEP_MS = 120;
let stepDelay = Math.round(BASE_STEP_MS * 1.20);

const FOOD_SCALE = 2.42;
const MAX_OVERFLOW_PCT = 0.65;
const MAX_OVERFLOW_TILES = 0.9;

const HEARTS_BASE = 12;
const HEARTS_COUNT = Math.max(1, Math.round(HEARTS_BASE * 0.6));

const SPEED_MULT_BASE = 0.975;
const EXTRA_STEP_PCT = 0.003;
const SPEED_MULT_COMBINED = SPEED_MULT_BASE - EXTRA_STEP_PCT;
const MIN_STEP = 25;
const SMOOTH_LERP = 0.14;

/* categories */
const categoryConfig = {
  balzam:   {prefix:'balzam',    count:8,  points:50,  w:1, h:1, weight: 1},
  cream:    {prefix:'Cream',     count:3,  points:100, w:1, h:2, weight: 1},
  shampoo:  {prefix:'Shampoo',   count:3,  points:150, w:1, h:2, weight: 1},
  tip:      {prefix:'tip',       count:2,  points:200, w:1, h:2, weight: 0.35}
};
const hairsprayConfig = { prefix:'HairSpray', count:3, points:300, w:1, h:2 };

/* ========== DOM & canvas ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('container');
const btnRestart = document.getElementById('btnRestart');
const btnShare = document.getElementById('btnShare');

let tileSize, canvasW, canvasH;
function resizeCanvas(){
  const maxW = Math.min(window.innerWidth - 40, 960);
  const maxH = window.innerHeight - 220;
  const size = Math.floor(Math.min(maxW / COLS, maxH / ROWS));
  tileSize = Math.max(20, size);
  canvasW = tileSize * COLS;
  canvasH = tileSize * ROWS;
  canvas.width = canvasW;
  canvas.height = canvasH;
  container.style.width = canvasW + 'px';
  container.style.height = canvasH + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ========== Load images ========== */
const imagesByCategory = {};
for (const k in categoryConfig){
  imagesByCategory[k] = [];
  const cfg = categoryConfig[k];
  for (let i=1;i<=cfg.count;i++){
    const img = new Image();
    img.src = `assets/${cfg.prefix}${i}.png`;
    imagesByCategory[k].push(img);
  }
}
const hairsprayImages = [];
for (let i=1;i<=hairsprayConfig.count;i++){
  const img = new Image();
  img.src = `assets/${hairsprayConfig.prefix}${i}.png`;
  hairsprayImages.push(img);
}

const headImg = new Image(); headImg.src = 'golova.png';
const telo1 = new Image(); telo1.src = 'telo1.png';
const telo2 = new Image(); telo2.src = 'telo2.png';

/* ========== State ========== */
let snake = [];
let dx = 1, dy = 0;
let food = null;
let extraFood = null;
let particles = [];
let gameOver = false;
let timerId = null;
let eatenSinceSpeedup = 0;
let totalEaten = 0;
let scoreVar = 0;
let globalTime = 0;

/* ===== LeadTeh & Debug ===== */
const LEADTEH_URL = 'https://rb731135.leadteh.ru/inner_webhook/js/a515a26d-58ab-4b10-ac00-0be7f617530e';
const DEBUG_UI = true; // выключите на проде

/* === Telegram helpers === */
function ensureTelegramReady(){
  try{
    if (window.Telegram?.WebApp){
      Telegram.WebApp.ready();
      Telegram.WebApp.expand && Telegram.WebApp.expand();
    }
  }catch(e){}
}
ensureTelegramReady();

function isInTelegramWebApp(){
  try{ return Boolean(window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe); }
  catch(_){ return false; }
}
function getTelegramIdOrNull(){
  const tg = window.Telegram?.WebApp;
  const u = tg?.initDataUnsafe?.user;
  return (u && u.id) ? String(u.id) : '';
}

/* ========== Utils ========== */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function pointOnSnake(x,y){ return snake.some(s => s.x===x && s.y===y); }
function rectFree(x,y,w,h){
  if (x<0 || y<0 || x+w>COLS || y+h>ROWS) return false;
  for (let sx=x; sx<x+w; sx++) for (let sy=y; sy<y+h; sy++) if(pointOnSnake(sx,sy)) return false;
  return true;
}
function lerp(a,b,t){ return a + (b-a) * t; }
function chooseCategory(){
  const keys = Object.keys(categoryConfig);
  const pool = [];
  for (const k of keys){
    const w = categoryConfig[k].weight;
    const times = Math.max(1, Math.round(w * 10));
    for (let i=0;i<times;i++) pool.push(k);
  }
  return pool[randInt(0, pool.length-1)];
}

/* ========== Food placement ========== */
let pendingHairspray = false;
function placeFood(){
  const maxAttempts = 1000;
  let attempts=0;
  food = null;
  while(attempts++ < maxAttempts){
    const cat = chooseCategory();
    const cfg = categoryConfig[cat];
    const w = cfg.w, h = cfg.h;
    const x = randInt(0, COLS - w);
    const y = randInt(0, ROWS - h);
    if (!rectFree(x,y,w,h)) continue;
    const imgs = imagesByCategory[cat];
    const img = imgs.length ? imgs[randInt(0, imgs.length-1)] : null;
    food = {x,y,cat,img,points:cfg.points,w,h};
    break;
  }
  if (!food){
    outer: for (let yy=0; yy<ROWS; yy++){
      for (let xx=0; xx<COLS; xx++){
        if (!pointOnSnake(xx,yy)){
          const imgs = imagesByCategory['balzam'];
          food = {x:xx,y:yy,cat:'balzam',img:imgs[0]||null,points:50,w:1,h:1};
          break outer;
        }
      }
    }
  }

  if (pendingHairspray){
    const wH = hairsprayConfig.w, hH = hairsprayConfig.h;
    let placed = false;
    let attempts2 = 0;
    while(attempts2++ < 800 && !placed){
      const x = randInt(0, COLS - wH);
      const y = randInt(0, ROWS - hH);
      if (!rectFree(x,y,wH,hH)) continue;
      if (!(x + wH <= food.x || x >= food.x + food.w || y + hH <= food.y || y >= food.y + food.h)) continue;
      const img = hairsprayImages.length ? hairsprayImages[randInt(0, hairsprayImages.length-1)] : null;
      extraFood = { x, y, cat: 'hairspray', img, points: hairsprayConfig.points, w: wH, h: hH, expiresAt: performance.now() + 3000 };
      placed = true;
    }
    pendingHairspray = false;
  }
}

/* ========== Smooth segments ========== */
function createSegment(x,y){
  return { x, y, px: x*tileSize + tileSize/2, py: y*tileSize + tileSize/2 };
}

/* ========== Init / restart ========== */
function initGame(){
  const cx = Math.floor(COLS/2);
  const cy = Math.floor(ROWS/2);
  snake = [ createSegment(cx,cy), createSegment(cx-1,cy), createSegment(cx-2,cy) ];
  dx = 1; dy = 0;
  stepDelay = Math.round(BASE_STEP_MS * 1.20);
  food = null;
  extraFood = null;
  pendingHairspray = false;
  particles = [];
  gameOver = false;
  eatenSinceSpeedup = 0;
  totalEaten = 0;
  scoreVar = 0;
  placeFood();
  btnRestart.style.display = 'none';
  btnShare.style.display = 'none';
  if (timerId) clearTimeout(timerId);
  scheduleNextStep();
  requestAnimationFrame(renderLoop);
}

/* ========== Step logic ========== */
function willCollide(nx, ny){
  if (nx<0 || ny<0 || nx>=COLS || ny>=ROWS) return true;
  for (let i=1;i<snake.length;i++) if (snake[i].x===nx && snake[i].y===ny) return true;
  return false;
}

/* ==== DEBUG overlay helpers ==== */
const $dbg = document.getElementById('debugOverlay');
const $dbgText = document.getElementById('dbgText');
const $dbgSend = document.getElementById('dbgSend');
const $dbgHide = document.getElementById('dbgHide');

function dbgShow(obj){
  if (!DEBUG_UI) return;
  $dbg.style.display = 'block';
  $dbgText.textContent = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
}
function dbgAppend(line){
  if (!DEBUG_UI) return;
  $dbg.style.display = 'block';
  $dbgText.textContent += (typeof line === 'string' ? line : JSON.stringify(line)) + '\n';
}
$dbgHide?.addEventListener('click', ()=> $dbg.style.display='none');

function trySendBeacon(url, urlSearchParams){
  try{
    if (!navigator.sendBeacon) return false;
    const blob = new Blob([urlSearchParams.toString()], { type:'application/x-www-form-urlencoded; charset=UTF-8' });
    return navigator.sendBeacon(url, blob);
  }catch(_){ return false; }
}

/* ========== GAME OVER: отправка в LeadTeh + debug ======= */
async function onGameOver(){
  const score = Number(scoreVar) || 0;
  const username = getPlayerName();
  const tg_id = getTelegramIdOrNull();
  const data = { username, score: String(score), tg_id, contact_by:'webapp', search:'snake_game' };

  dbgShow({ phase:'GAME_OVER', inTelegram: isInTelegramWebApp(), tg_id, username, score, ua: navigator.userAgent });

  if (tg_id){
    const params = new URLSearchParams(data);
    const ok = trySendBeacon(LEADTEH_URL, params);
    if (ok) dbgAppend('LeadTeh: sendBeacon=true');
    if (!ok){
      try{
        const res = await fetch(LEADTEH_URL, {
          method:'POST',
          headers:{ 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8' },
          body: params
        });
        dbgAppend('LeadTeh fetch status: ' + res.status);
      }catch(e){
        dbgAppend('LeadTeh fetch error: ' + (e?.message || e));
      }
    }
  } else {
    dbgAppend('[LeadTeh] Пропущено: tg_id пустой (не из Telegram WebApp?)');
  }

  // (опционально) Google Apps Script лидерборд
  try { await submitScoreSimple(score); } catch(e){ dbgAppend('GAS error: ' + (e?.message || e)); }

  btnRestart.style.display = 'block';
  btnShare.style.display = 'block';
}

/* ====== остальная игровая логика ====== */
function performStep(){
  if (gameOver) return;
  const headGX = snake[0].x + dx;
  const headGY = snake[0].y + dy;

  if (willCollide(headGX, headGY)){
    gameOver = true;
    onGameOver();
    return;
  }

  snake.unshift( createSegment(headGX, headGY) );

  // extraFood
  let ateExtra = false;
  if (extraFood){
    if (headGX >= extraFood.x && headGX < extraFood.x + extraFood.w &&
        headGY >= extraFood.y && headGY < extraFood.y + extraFood.h){
      scoreVar += extraFood.points;
      totalEaten++; eatenSinceSpeedup++;
      spawnParticlesAt(extraFood.x, extraFood.y, extraFood.w, extraFood.h, 'hairspray');
      extraFood = null; ateExtra = true;
    }
  }

  // main food
  let ateMain = false;
  if (food && !ateExtra){
    if (headGX >= food.x && headGX < food.x + food.w &&
        headGY >= food.y && headGY < food.y + food.h){
      ateMain = true;
      totalEaten++; eatenSinceSpeedup++;
      scoreVar += food.points;
      spawnParticlesAt(food.x, food.y, food.w, food.h, food.cat);
      pendingHairspray = (Math.random() < 0.10);
      placeFood();
    }
  }

  if (!ateMain && !ateExtra) snake.pop();

  if (eatenSinceSpeedup >= 3){
    stepDelay = Math.max(MIN_STEP, Math.round(stepDelay * SPEED_MULT_COMBINED));
    eatenSinceSpeedup = 0;
  }

  if (extraFood && performance.now() > extraFood.expiresAt){
    extraFood = null;
  }

  scheduleNextStep();
}
function scheduleNextStep(){
  if (timerId) clearTimeout(timerId);
  timerId = setTimeout(performStep, stepDelay);
}

/* ========== Particles ========== */
function spawnParticlesAt(cellX, cellY, cellsW, cellsH, cat){
  const cx = (cellX + cellsW/2) * tileSize;
  const cy = (cellY + cellsH/2) * tileSize;
  const char = (cat === 'hairspray') ? '⭐️' : '❤️';
  const SLOW_MULT = 0.6;
  for (let i=0;i<Math.max(3, HEARTS_COUNT);i++){
    const angle = Math.random() * Math.PI * 2;
    const baseSpeed = 0.6 + Math.random() * 1.6;
    const vyBias = (cat === 'hairspray') ? -0.4 - Math.random()*0.2 : (Math.random()*0.4 - 0.2);
    const life = 40 + Math.floor(Math.random()*40);
    const size = tileSize * (0.45 + Math.random()*0.8);
    const vx = Math.cos(angle) * baseSpeed * (0.6 + Math.random()*0.9) * SLOW_MULT;
    const vy = (Math.sin(angle) * baseSpeed * (0.6 + Math.random()*0.9) + vyBias) * SLOW_MULT;
    particles.push({
      type:'emoji',
      char,
      x: cx + (Math.random()-0.5) * tileSize * 0.2,
      y: cy + (Math.random()-0.5) * tileSize * 0.2,
      vx, vy, size, life, maxLife: life
    });
  }
}
function updateParticles(){
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.995; p.vy += 0.01;
    p.life--;
    if (p.life <= 0) particles.splice(i,1);
  }
}

/* ========== Drawing helpers & draw ======= */
function drawEllipseFilled(cx, cy, rx, ry, fillStyle, alpha=1, rotation=0){
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(rotation);
  ctx.globalAlpha = alpha; ctx.beginPath();
  ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2);
  ctx.fillStyle = fillStyle; ctx.fill(); ctx.restore();
}
function computeImageDrawRect(areaLeft, areaTop, areaW, areaH){
  const desiredW = Math.round(areaW * FOOD_SCALE);
  const desiredH = Math.round(areaH * FOOD_SCALE);
  const allowedOverflowW = Math.min(Math.round(areaW * MAX_OVERFLOW_PCT), Math.round(tileSize * MAX_OVERFLOW_TILES));
  const allowedOverflowH = Math.min(Math.round(areaH * MAX_OVERFLOW_PCT), Math.round(tileSize * MAX_OVERFLOW_TILES));
  const maxAllowedW = areaW + allowedOverflowW;
  const maxAllowedH = areaH + allowedOverflowH;
  let drawW = Math.min(desiredW, maxAllowedW);
  let drawH = Math.min(desiredH, maxAllowedH);
  return { drawW, drawH, areaLeft, areaTop, areaW, areaH, maxAllowedW, maxAllowedH };
}
function drawSingleFood(it, nowSec){
  if (!it) return;
  const cellsW = it.w, cellsH = it.h;
  const areaW = tileSize * cellsW;
  const areaH = tileSize * cellsH;
  const areaLeft = it.x * tileSize;
  const areaTop  = it.y * tileSize;

  if (it.cat === 'hairspray'){
    const pulse = 1 + 0.20 * Math.sin(nowSec * 4 + it.x * 1.7 + it.y * 0.9);
    const cx = Math.round(areaLeft + areaW/2);
    const cy = Math.round(areaTop + areaH/2 + tileSize*0.08);
    const base = Math.min(areaW, areaH);
    const rx = Math.max(10, Math.round((base/2 + 12) * pulse));
    const ry = Math.max(8, Math.round((base/2 + 8) * pulse * 0.82));
    drawEllipseFilled(cx, cy, rx, ry, 'rgba(255,235,0,0.98)', 0.98);
  }

  if (it.img && it.img.complete && it.img.naturalWidth && it.img.naturalHeight){
    const c = computeImageDrawRect(areaLeft, areaTop, areaW, areaH);
    const iw = it.img.naturalWidth, ih = it.img.naturalHeight;
    const aspect = iw / ih;
    let drawW = c.drawW;
    let drawH = Math.round(drawW / aspect);
    if (drawH > c.maxAllowedH){ drawH = c.maxAllowedH; drawW = Math.round(drawH * aspect); }
    const drawX = Math.round(areaLeft + (areaW - drawW)/2);
    const drawY = Math.round(areaTop + (areaH - drawH)/2);
    ctx.drawImage(it.img, drawX, drawY, drawW, drawH);
  } else {
    const c = computeImageDrawRect(areaLeft, areaTop, areaW, areaH);
    const dw = Math.round(Math.min(c.drawW, c.maxAllowedW * 0.95));
    const dh = Math.round(dw / 1.2);
    const dx = Math.round(areaLeft + (areaW - dw)/2);
    const dy = Math.round(areaTop + (areaH - dh)/2);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(dx, dy, dw, dh);
  }
}
function drawFood(nowSec){
  drawSingleFood(food, nowSec);
  if (extraFood){ drawSingleFood(extraFood, nowSec); }
}

function drawSnake(){
  for (let i=0;i<snake.length;i++){
    const s = snake[i];
    const targetCx = s.x * tileSize + tileSize/2;
    const targetCy = s.y * tileSize + tileSize/2;
    s.px = lerp(s.px, targetCx, SMOOTH_LERP);
    s.py = lerp(s.py, targetCy, SMOOTH_LERP);
  }

  for (let i=1; i<snake.length; i++){
    const s = snake[i];
    const size = Math.max(6, Math.floor(tileSize * 1.06));
    if (i === snake.length - 1){
      if (telo2 && telo2.complete && telo2.naturalWidth){
        const tail = snake[snake.length - 1];
        const prev = snake[snake.length - 2];
        const angle = Math.atan2(prev.py - tail.py, prev.px - tail.px);
        ctx.save(); ctx.translate(tail.px, tail.py); ctx.rotate(angle + Math.PI/2);
        let iw = telo2.naturalWidth, ih = telo2.naturalHeight;
        let aspect = iw / ih;
        let dw = size, dh = size;
        if (dw / dh > aspect) dw = Math.round(dh * aspect); else dh = Math.round(dw / aspect);
        ctx.drawImage(telo2, -dw/2, -dh/2, dw, dh);
        ctx.restore();
      } else {
        ctx.fillStyle = '#E159A9';
        ctx.beginPath(); ctx.arc(s.px, s.py, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill();
      }
    } else {
      if (telo1 && telo1.complete && telo1.naturalWidth){
        let iw = telo1.naturalWidth, ih = telo1.naturalHeight;
        let aspect = iw / ih;
        let dw = size, dh = size;
        if (dw / dh > aspect) dw = Math.round(dh * aspect); else dh = Math.round(dw / aspect);
        ctx.drawImage(telo1, Math.round(s.px - dw/2), Math.round(s.py - dh/2), dw, dh);
      } else {
        ctx.fillStyle = '#E159A9';
        ctx.beginPath(); ctx.arc(s.px, s.py, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill();
      }
    }
  }

  const head = snake[0];
  const hx = head.px, hy = head.py;
  const headScale = 1.42;
  const headSizeBase = Math.max(6, Math.floor(tileSize * headScale));
  if (headImg && headImg.complete && headImg.naturalWidth){
    const dirAngle = Math.atan2(dy, dx);
    ctx.save(); ctx.translate(hx, hy); ctx.rotate(dirAngle + Math.PI/2);
    let iw = headImg.naturalWidth, ih = headImg.naturalHeight;
    let aspect = iw / ih;
    let dw = headSizeBase, dh = headSizeBase;
    if (dw / dh > aspect) dw = Math.round(dh * aspect); else dh = Math.round(dw / aspect);
    ctx.drawImage(headImg, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  } else {
    ctx.fillStyle = '#E159A9';
    ctx.beginPath(); ctx.arc(hx, hy, Math.max(4, Math.floor(tileSize/2 - 2)), 0, Math.PI*2); ctx.fill();
    const eyeR = Math.max(2, Math.floor(tileSize/6));
    const eyeOffsetX = tileSize / 4;
    const eyeOffsetY = tileSize / 6;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(hx - eyeOffsetX, hy - eyeOffsetY, eyeR, 0, Math.PI*2);
    ctx.arc(hx + eyeOffsetX, hy - eyeOffsetY, eyeR, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(hx - eyeOffsetX, hy - eyeOffsetY, Math.max(1, Math.floor(eyeR/2)), 0, Math.PI*2);
    ctx.arc(hx + eyeOffsetX, hy - eyeOffsetY, Math.max(1, Math.floor(eyeR/2)), 0, Math.PI*2);
    ctx.fill();
  }
}

function drawParticles(){
  if (!particles.length) return;
  ctx.save();
  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    if (p.type === 'emoji'){
      ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
      ctx.font = `${Math.max(8, Math.floor(p.size))}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.char, Math.round(p.x), Math.round(p.y));
      ctx.globalAlpha = 1;
    } else {
      ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
      ctx.fillStyle = p.color || '#fff';
      ctx.beginPath(); ctx.arc(Math.round(p.x), Math.round(p.y), p.r, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  ctx.restore();
}
function drawScore(){
  ctx.save();
  ctx.fillStyle = '#000';
  ctx.font = `${Math.max(14, Math.floor(tileSize * 0.7))}px Futura, Arial, sans-serif`;
  ctx.textBaseline = 'top';
  ctx.fillText('Счёт: ' + scoreVar, Math.max(6, tileSize*0.15), Math.max(6, tileSize*0.12));
  ctx.restore();
}

/* ========== Render loop ========== */
function renderLoop(ts){
  globalTime = ts / 1000;
  if (extraFood && performance.now() > extraFood.expiresAt) extraFood = null;

  ctx.clearRect(0,0,canvasW,canvasH);
  drawFood(globalTime);
  drawSnake();
  drawParticles();
  drawScore();
  updateParticles();
  requestAnimationFrame(renderLoop);
}

/* ========== Input ========== */
function setDir(nx, ny){
  if (nx === -dx && ny === -dy) return;
  dx = nx; dy = ny;
}
document.addEventListener('keydown', e=>{
  if (e.key === 'ArrowUp') setDir(0,-1);
  else if (e.key === 'ArrowDown') setDir(0,1);
  else if (e.key === 'ArrowLeft') setDir(-1,0);
  else if (e.key === 'ArrowRight') setDir(1,0);
});
document.getElementById('btnUp').addEventListener('click', ()=> setDir(0,-1));
document.getElementById('btnDown').addEventListener('click', ()=> setDir(0,1));
document.getElementById('btnLeft').addEventListener('click', ()=> setDir(-1,0));
document.getElementById('btnRight').addEventListener('click', ()=> setDir(1,0));

// touch swipe
let tsx=0, tsy=0;
canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; tsx=t.clientX; tsy=t.clientY; }, {passive:true});
canvas.addEventListener('touchend', e=>{
  const t=e.changedTouches[0];
  const dxs = t.clientX - tsx, dys = t.clientY - tsy;
  if (Math.abs(dxs) < 20 && Math.abs(dys) < 20) return;
  if (Math.abs(dxs) > Math.abs(dys)){ if (dxs > 0) setDir(1,0); else setDir(-1,0); }
  else { if (dys > 0) setDir(0,1); else setDir(0,-1); }
}, {passive:true});

/* ========== Overlays ========== */
btnRestart.addEventListener('click', ()=> initGame());

/* ========== ЛИДЕРБОРД: Google Apps Script (для модалки) ========== */
const LB_URL = 'https://script.google.com/macros/s/AKfycbzgKYvvZRDvZTaHmMSDJpH0YsUyUIGiFhn8_Tixwz9mh78dG2cw1SbbBfBMDUkXnbj-/exec';

function getPlayerName(){
  let name = localStorage.getItem('hp_player_name');
  if (!name) {
    name = prompt('Как тебя подписать в таблице лидеров?') || 'Игрок';
    name = name.trim().slice(0, 40);
    localStorage.setItem('hp_player_name', name);
  }
  return name;
}
async function submitScoreSimple(score){
  const username = getPlayerName();
  const tg_id = getTelegramIdOrNull();
  await fetch(LB_URL, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ username, score, tg_id })
  });
}
async function fetchLeaderboardSimple(){
  const res = await fetch(LB_URL);
  if (!res.ok) throw new Error('LB fetch failed');
  return res.json();
}

// overlay logic
const lbModal = document.getElementById('leaderboardModal');
const lbList  = document.getElementById('lbList');
const lbClose = document.getElementById('lbClose');

function openLeaderboard(top=[], meName=null, myTgId=''){
  lbList.innerHTML = '';
  top.forEach((row, idx)=>{
    const isMe = (myTgId && row.tg_id === myTgId) || (!myTgId && row.username === meName);
    const li = document.createElement('li');
    if (isMe) li.className = 'lb-item-me';
    li.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:12px;">
        <span>#${idx+1} ${row.username || 'Игрок'}${row.tg_id ? ' · tg:'+row.tg_id : ''}</span>
        <strong>${row.score}</strong>
      </div>`;
    lbList.appendChild(li);
  });
  lbModal.hidden = false;
}
lbClose?.addEventListener('click', ()=> lbModal.hidden = true);
lbModal?.addEventListener('click', e=>{ if(e.target===lbModal) lbModal.hidden=true; });

// кнопка "Таблица лидеров"
btnShare.addEventListener('click', async ()=>{
  try {
    const data = await fetchLeaderboardSimple();
    openLeaderboard(data.top || [], localStorage.getItem('hp_player_name'), getTelegramIdOrNull());
  } catch(e){
    alert('Не удалось загрузить таблицу :(');
    console.warn(e);
  }
});

/* ===== DEBUG overlay кнопка «Тест POST» ===== */
document.getElementById('dbgSend')?.addEventListener('click', async ()=>{
  const username = getPlayerName();
  const tg_id = getTelegramIdOrNull();
  const score = 1234;
  const payload = new URLSearchParams({ username, score: String(score), tg_id, contact_by:'webapp', search:'snake_game' });

  dbgAppend({event:'dbgSend click', inTelegram:isInTelegramWebApp(), tg_id, username, score});
  const ok = trySendBeacon(LEADTEH_URL, payload);
  if (ok) dbgAppend('sendBeacon: true (отправлено)');
  else {
    try {
      const res = await fetch(LEADTEH_URL, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8'}, body: payload });
      dbgAppend('fetch status: ' + res.status);
    } catch(e){
      dbgAppend('fetch error: ' + (e?.message||e));
    }
  }
});

/* ========== Start ========== */
resizeCanvas();
initGame();

/* ===== debug API в window ===== */
window._hp = Object.assign(window._hp || {}, {
  debugEnv(){
    const tg = window.Telegram?.WebApp;
    const user = tg?.initDataUnsafe?.user;
    const info = {
      inTelegram: isInTelegramWebApp(),
      hasWebApp: !!tg,
      user,
      tg_id: user?.id ? String(user.id) : '',
      ua: navigator.userAgent
    };
    dbgShow(info);
    return info;
  },
  debugSendOnce(){ document.getElementById('dbgSend')?.click(); }
});
</script>
</body>
</html>

