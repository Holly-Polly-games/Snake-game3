<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Holly Polly — Змейка</title>

<!-- Telegram WebApp SDK -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
  :root{ --page-bg:#FF007F; --field-bg:#E1CCFB; --control-green:#2e8b57; }
  html,body{height:100%;margin:0;}
  body{ background:var(--page-bg); display:flex; flex-direction:column; align-items:center;
        font-family:"Futura","Trebuchet MS",Arial,sans-serif; padding:12px; box-sizing:border-box; }
  header{ text-align:center; margin-bottom:8px; }
  header img{ max-height:84px; display:block; margin:0 auto; }
  header .slogan{ color:#000; margin-top:8px; font-weight:700; }
  #container{ background:var(--field-bg); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative; }
  canvas{ display:block; image-rendering: optimizeQuality; }
  .overlay-btn{ position:absolute; left:50%; transform:translateX(-50%); background:var(--control-green); color:#fff;
    border:none; padding:12px 22px; border-radius:10px; font-size:18px; display:none; z-index:20; cursor:pointer; }
  #btnRestart{ top:42%; } #btnShare{ top:56%; }
  #controls{ margin-top:10px; display:grid; grid-template-areas: ". up ." "left . right" ". down ."; gap:8px; }
  .ctrl-btn{ width:64px; height:64px; border-radius:999px; background:var(--control-green); color:#fff; border:none; font-size:22px; cursor:pointer; }
  @media(max-width:480px){ .ctrl-btn{ width:54px; height:54px; font-size:18px; } }
  .lb-modal{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:50; }
  .lb-modal[hidden]{ display:none; }
  .lb-card{ background:#fff; border-radius:14px; width:min(520px,92vw); box-shadow:0 10px 40px rgba(0,0,0,.35); padding:14px 16px; }
  .lb-head{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .lb-head h3{ margin:0; font-size:20px; }
  .lb-close{ background:#eee; border:none; border-radius:8px; padding:6px 10px; cursor:pointer; }
  .lb-list{ margin:8px 0 0; padding:0 18px 12px; max-height:60vh; overflow:auto; }
  .lb-item-me{ background:#FFEBF7; border-radius:10px; padding:4px 8px; }
</style>
</head>
<body>
  <header>
    <img src="logo.png" alt="logo">
    <div class="slogan">Holly Polly — твоя лучшая подруга!</div>
  </header>

  <div id="container">
    <canvas id="game"></canvas>
    <button id="btnRestart" class="overlay-btn">Заново</button>
    <button id="btnShare" class="overlay-btn">Таблица лидеров</button>
  </div>

  <!-- Модалка лидеров -->
  <div id="leaderboardModal" class="lb-modal" hidden>
    <div class="lb-card">
      <div class="lb-head">
        <h3>Таблица лидеров</h3>
        <button id="lbClose" class="lb-close">✕</button>
      </div>
      <ol id="lbList" class="lb-list"></ol>
    </div>
  </div>

  <!-- Кнопки управления -->
  <div id="controls">
    <div></div><button class="ctrl-btn" id="btnUp">↑</button><div></div>
    <button class="ctrl-btn" id="btnLeft">←</button><div></div><button class="ctrl-btn" id="btnRight">→</button>
    <div></div><button class="ctrl-btn" id="btnDown">↓</button><div></div>
  </div>

<script>
/* ====== Настройки ====== */
const LB_URL = 'https://script.google.com/macros/s/AKfycby_HWJOkI67NTArp_y0gXcc82mIgUC-vesYMoo6jkjsGrIo2T4XcpNLBp9j4WATVakz/exec'; // ваш GAS /exec
const COLS = 12, ROWS = 22, BASE_STEP_MS = 120;
let stepDelay = Math.round(BASE_STEP_MS * 1.20);

/* ====== Telegram bootstrap ====== */
(function tgReady(){
  try{ if (Telegram?.WebApp){ Telegram.WebApp.ready(); Telegram.WebApp.expand?.(); } }catch(e){}
})();
function getTgUser(){ return Telegram?.WebApp?.initDataUnsafe?.user || null; }
function getTgId(){ const u=getTgUser(); return u?.id ? String(u.id) : ''; }
function getTgUsername(){
  const u=getTgUser(); if (!u) return '';
  if (u.username) return '@'+u.username;
  const fn=u.first_name||'', ln=u.last_name||''; return (fn+' '+ln).trim() || 'Игрок';
}

/* ====== Canvas / игра (ваш код без изменений)… ====== */
const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
const container=document.getElementById('container'); const btnRestart=document.getElementById('btnRestart'); const btnShare=document.getElementById('btnShare');
let tileSize,canvasW,canvasH;
function resizeCanvas(){ const maxW=Math.min(innerWidth-40,960); const maxH=innerHeight-220; const size=Math.floor(Math.min(maxW/COLS,maxH/ROWS));
  tileSize=Math.max(20,size); canvasW=tileSize*COLS; canvasH=tileSize*ROWS; canvas.width=canvasW; canvas.height=canvasH; container.style.width=canvasW+'px'; container.style.height=canvasH+'px'; }
addEventListener('resize',resizeCanvas); resizeCanvas();

const categoryConfig={ balzam:{prefix:'balzam',count:8,points:50,w:1,h:1,weight:1}, cream:{prefix:'Cream',count:3,points:100,w:1,h:2,weight:1}, shampoo:{prefix:'Shampoo',count:3,points:150,w:1,h:2,weight:1}, tip:{prefix:'tip',count:2,points:200,w:1,h:2,weight:0.35} };
const hairsprayConfig={ prefix:'HairSpray', count:3, points:300, w:1, h:2 };
const imagesByCategory={}; for (const k in categoryConfig){ imagesByCategory[k]=[]; const cfg=categoryConfig[k]; for(let i=1;i<=cfg.count;i++){ const img=new Image(); img.src=`assets/${cfg.prefix}${i}.png`; imagesByCategory[k].push(img);} }
const hairsprayImages=[]; for(let i=1;i<=hairsprayConfig.count;i++){ const img=new Image(); img.src=`assets/${hairsprayConfig.prefix}${i}.png`; hairsprayImages.push(img); }
const headImg=new Image(); headImg.src='golova.png'; const telo1=new Image(); telo1.src='telo1.png'; const telo2=new Image(); telo2.src='telo2.png';

let snake=[], dx=1, dy=0, food=null, extraFood=null, particles=[], gameOver=false, timerId=null, eatenSinceSpeedup=0, totalEaten=0, scoreVar=0, globalTime=0, pendingHairspray=false;
const FOOD_SCALE=2.42, MAX_OVERFLOW_PCT=0.65, MAX_OVERFLOW_TILES=0.9, HEARTS_BASE=12, HEARTS_COUNT=Math.max(1,Math.round(HEARTS_BASE*0.6)), SPEED_MULT_BASE=0.975, EXTRA_STEP_PCT=0.003, SPEED_MULT_COMBINED=SPEED_MULT_BASE-EXTRA_STEP_PCT, MIN_STEP=25, SMOOTH_LERP=0.14;

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function pointOnSnake(x,y){ return snake.some(s=>s.x===x && s.y===y); }
function rectFree(x,y,w,h){ if(x<0||y<0||x+w>COLS||y+h>ROWS) return false; for(let sx=x;sx<x+w;sx++) for(let sy=y;sy<y+h;sy++) if(pointOnSnake(sx,sy)) return false; return true; }
function lerp(a,b,t){ return a + (b-a)*t; }
function chooseCategory(){ const pool=[]; for (const k of Object.keys(categoryConfig)){ const times=Math.max(1,Math.round(categoryConfig[k].weight*10)); for(let i=0;i<times;i++) pool.push(k);} return pool[randInt(0,pool.length-1)]; }

function placeFood(){ const maxAttempts=1000; let attempts=0; food=null;
  while(attempts++<maxAttempts){ const cat=chooseCategory(), cfg=categoryConfig[cat]; const w=cfg.w,h=cfg.h,x=randInt(0,COLS-w),y=randInt(0,ROWS-h);
    if(!rectFree(x,y,w,h)) continue; const imgs=imagesByCategory[cat]; const img=imgs.length?imgs[randInt(0,imgs.length-1)]:null; food={x,y,cat,img,points:cfg.points,w,h}; break; }
  if(!food){ outer: for(let yy=0;yy<ROWS;yy++) for(let xx=0;xx<COLS;xx++){ if(!pointOnSnake(xx,yy)){ const imgs=imagesByCategory['balzam']; food={x:xx,y:yy,cat:'balzam',img:imgs[0]||null,points:50,w:1,h:1}; break outer; } } }
  if(pendingHairspray){ const wH=hairsprayConfig.w, hH=hairsprayConfig.h; let placed=false, attempts2=0;
    while(attempts2++<800 && !placed){ const x=randInt(0,COLS-wH), y=randInt(0,ROWS-hH); if(!rectFree(x,y,wH,hH)) continue;
      if(!(x+wH<=food.x||x>=food.x+food.w||y+hH<=food.y||y>=food.y+food.h)) continue; const img=hairsprayImages.length?hairsprayImages[randInt(0,hairsprayImages.length-1)]:null;
      extraFood={x,y,cat:'hairspray',img,points:hairsprayConfig.points,w:wH,h:hH,expiresAt:performance.now()+3000}; placed=true; } pendingHairspray=false; } }

function createSegment(x,y){ return { x, y, px:x*tileSize+tileSize/2, py:y*tileSize+tileSize/2 }; }

function initGame(){ const cx=Math.floor(COLS/2), cy=Math.floor(ROWS/2);
  snake=[createSegment(cx,cy),createSegment(cx-1,cy),createSegment(cx-2,cy)];
  dx=1; dy=0; stepDelay=Math.round(BASE_STEP_MS*1.20); food=null; extraFood=null; pendingHairspray=false; particles=[]; gameOver=false; eatenSinceSpeedup=0; totalEaten=0; scoreVar=0;
  placeFood(); btnRestart.style.display='none'; btnShare.style.display='none'; if(timerId) clearTimeout(timerId); scheduleNextStep(); requestAnimationFrame(renderLoop); }

function drawEllipseFilled(cx,cy,rx,ry,fillStyle,alpha=1,rotation=0){ ctx.save(); ctx.translate(cx,cy); ctx.rotate(rotation); ctx.globalAlpha=alpha; ctx.beginPath(); ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2); ctx.fillStyle=fillStyle; ctx.fill(); ctx.restore(); }
function computeImageDrawRect(areaLeft,areaTop,areaW,areaH){ const desiredW=Math.round(areaW*FOOD_SCALE), desiredH=Math.round(areaH*FOOD_SCALE);
  const allowedOverflowW=Math.min(Math.round(areaW*MAX_OVERFLOW_PCT),Math.round(tileSize*MAX_OVERFLOW_TILES));
  const allowedOverflowH=Math.min(Math.round(areaH*MAX_OVERFLOW_PCT),Math.round(tileSize*MAX_OVERFLOW_TILES));
  const maxAllowedW=areaW+allowedOverflowW, maxAllowedH=areaH+allowedOverflowH; let drawW=Math.min(desiredW,maxAllowedW), drawH=Math.min(desiredH,maxAllowedH);
  return {drawW,drawH,areaLeft,areaTop,areaW,areaH,maxAllowedW,maxAllowedH}; }
function drawSingleFood(it,nowSec){ if(!it) return; const cellsW=it.w,cellsH=it.h,areaW=tileSize*cellsW,areaH=tileSize*cellsH,areaLeft=it.x*tileSize,areaTop=it.y*tileSize;
  if(it.cat==='hairspray'){ const pulse=1+0.20*Math.sin(nowSec*4+it.x*1.7+it.y*0.9); const cx=Math.round(areaLeft+areaW/2), cy=Math.round(areaTop+areaH/2+tileSize*0.08);
    const base=Math.min(areaW,areaH), rx=Math.max(10,Math.round((base/2+12)*pulse)), ry=Math.max(8,Math.round((base/2+8)*pulse*0.82)); drawEllipseFilled(cx,cy,rx,ry,'rgba(255,235,0,0.98)',0.98); }
  if(it.img && it.img.complete && it.img.naturalWidth && it.img.naturalHeight){ const c=computeImageDrawRect(areaLeft,areaTop,areaW,areaH); const iw=it.img.naturalWidth, ih=it.img.naturalHeight, aspect=iw/ih;
    let drawW=c.drawW, drawH=Math.round(drawW/aspect); if(drawH>c.maxAllowedH){ drawH=c.maxAllowedH; drawW=Math.round(drawH*aspect); }
    const drawX=Math.round(areaLeft+(areaW-drawW)/2), drawY=Math.round(areaTop+(areaH-drawH)/2); ctx.drawImage(it.img,drawX,drawY,drawW,drawH);
  } else { const c=computeImageDrawRect(areaLeft,areaTop,areaW,areaH); const dw=Math.round(Math.min(c.drawW,c.maxAllowedW*0.95)), dh=Math.round(dw/1.2);
    const dx=Math.round(areaLeft+(areaW-dw)/2), dy=Math.round(areaTop+(areaH-dh)/2); ctx.fillStyle='#ff6b6b'; ctx.fillRect(dx,dy,dw,dh); } }
function drawFood(nowSec){ drawSingleFood(food,nowSec); if(extraFood) drawSingleFood(extraFood,nowSec); }

function drawSnake(){
  for(let i=0;i<snake.length;i++){ const s=snake[i], tx=s.x*tileSize+tileSize/2, ty=s.y*tileSize+tileSize/2; s.px=lerp(s.px,tx,SMOOTH_LERP); s.py=lerp(s.py,ty,SMOOTH_LERP); }
  for(let i=1;i<snake.length;i++){ const s=snake[i], size=Math.max(6,Math.floor(tileSize*1.06));
    if(i===snake.length-1){ if(telo2 && telo2.complete && telo2.naturalWidth){ const tail=snake[snake.length-1], prev=snake[snake.length-2], angle=Math.atan2(prev.py-tail.py,prev.px-tail.px);
        ctx.save(); ctx.translate(tail.px,tail.py); ctx.rotate(angle+Math.PI/2); let iw=telo2.naturalWidth, ih=telo2.naturalHeight, aspect=iw/ih; let dw=size, dh=size;
        if(dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect); ctx.drawImage(telo2,-dw/2,-dh/2,dw,dh); ctx.restore();
      } else { ctx.fillStyle='#E159A9'; ctx.beginPath(); ctx.arc(s.px,s.py,Math.max(4,Math.floor(tileSize/2-2)),0,Math.PI*2); ctx.fill(); } }
    else { if(telo1 && telo1.complete && telo1.naturalWidth){ let iw=telo1.naturalWidth, ih=telo1.naturalHeight, aspect=iw/ih; let dw=size, dh=size;
        if(dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect); ctx.drawImage(telo1,Math.round(s.px-dw/2),Math.round(s.py-dh/2),dw,dh);
      } else { ctx.fillStyle='#E159A9'; ctx.beginPath(); ctx.arc(s.px,s.py,Math.max(4,Math.floor(tileSize/2-2)),0,Math.PI*2); ctx.fill(); } } }
  const head=snake[0], hx=head.px, hy=head.py, headScale=1.42, headSize=Math.max(6,Math.floor(tileSize*headScale));
  if(headImg && headImg.complete && headImg.naturalWidth){ const dirAngle=Math.atan2(dy,dx); ctx.save(); ctx.translate(hx,hy); ctx.rotate(dirAngle+Math.PI/2);
    let iw=headImg.naturalWidth, ih=headImg.naturalHeight, aspect=iw/ih; let dw=headSize, dh=headSize; if(dw/dh>aspect) dw=Math.round(dh*aspect); else dh=Math.round(dw/aspect);
    ctx.drawImage(headImg,-dw/2,-dh/2,dw,dh); ctx.restore();
  } else { ctx.fillStyle='#E159A9'; ctx.beginPath(); ctx.arc(hx,hy,Math.max(4,Math.floor(tileSize/2-2)),0,Math.PI*2); ctx.fill();
    const eyeR=Math.max(2,Math.floor(tileSize/6)), ex=tileSize/4, ey=tileSize/6; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(hx-ex,hy-ey,eyeR,0,Math.PI*2); ctx.arc(hx+ex,hy-ey,eyeR,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(hx-ex,hy-ey,Math.max(1,Math.floor(eyeR/2)),0,Math.PI*2); ctx.arc(hx+ex,hy-ey,Math.max(1,Math.floor(eyeR/2)),0,Math.PI*2); ctx.fill(); } }

function drawParticles(){ if(!particles.length) return; ctx.save();
  for(let i=particles.length-1;i>=0;i--){ const p=particles[i];
    if(p.type==='emoji'){ ctx.globalAlpha=Math.max(0,p.life/p.maxLife);
      ctx.font=`${Math.max(8,Math.floor(p.size))}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(p.char,Math.round(p.x),Math.round(p.y)); ctx.globalAlpha=1;
    } else { ctx.globalAlpha=Math.max(0,p.life/p.maxLife); ctx.fillStyle=p.color||'#fff'; ctx.beginPath(); ctx.arc(Math.round(p.x),Math.round(p.y),p.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; } }
  ctx.restore(); }
function drawScore(){ ctx.save(); ctx.fillStyle='#000'; ctx.font=`${Math.max(14,Math.floor(tileSize*0.7))}px Futura, Arial, sans-serif`; ctx.textBaseline='top'; ctx.fillText('Счёт: '+scoreVar, Math.max(6,tileSize*0.15), Math.max(6,tileSize*0.12)); ctx.restore(); }
function renderLoop(ts){ globalTime=ts/1000; if(extraFood && performance.now()>extraFood.expiresAt) extraFood=null;
  ctx.clearRect(0,0,canvasW,canvasH); drawFood(globalTime); drawSnake(); drawParticles(); drawScore(); updateParticles(); requestAnimationFrame(renderLoop); }
function spawnParticlesAt(cellX,cellY,cellsW,cellsH,cat){ const cx=(cellX+cellsW/2)*tileSize, cy=(cellY+cellsH/2)*tileSize, char=(cat==='hairspray')?'⭐️':'❤️', SLOW_MULT=0.6;
  for(let i=0;i<Math.max(3,HEARTS_COUNT);i++){ const angle=Math.random()*Math.PI*2, baseSpeed=0.6+Math.random()*1.6, vyBias=(cat==='hairspray')?-0.4-Math.random()*0.2:(Math.random()*0.4-0.2);
    const life=40+Math.floor(Math.random()*40), size=tileSize*(0.45+Math.random()*0.8);
    const vx=Math.cos(angle)*baseSpeed*(0.6+Math.random()*0.9)*SLOW_MULT, vy=(Math.sin(angle)*baseSpeed*(0.6+Math.random()*0.9)+vyBias)*SLOW_MULT;
    particles.push({type:'emoji',char,x:cx+(Math.random()-0.5)*tileSize*0.2,y:cy+(Math.random()-0.5)*tileSize*0.2,vx,vy,size,life,maxLife:life}); } }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.995; p.vy+=0.01; p.life--; if(p.life<=0) particles.splice(i,1);} }

function willCollide(nx,ny){ if(nx<0||ny<0||nx>=COLS||ny>=ROWS) return true; for(let i=1;i<snake.length;i++) if(snake[i].x===nx && snake[i].y===ny) return true; return false; }
function performStep(){ if(gameOver) return; const headGX=snake[0].x+dx, headGY=snake[0].y+dy;
  if(willCollide(headGX,headGY)){ gameOver=true; onGameOver(); return; } snake.unshift(createSegment(headGX,headGY));
  let ateExtra=false; if(extraFood){ if(headGX>=extraFood.x && headGX<extraFood.x+extraFood.w && headGY>=extraFood.y && headGY<extraFood.y+extraFood.h){
      scoreVar+=extraFood.points; totalEaten++; eatenSinceSpeedup++; spawnParticlesAt(extraFood.x,extraFood.y,extraFood.w,extraFood.h,'hairspray'); extraFood=null; ateExtra=true; } }
  let ateMain=false; if(food && !ateExtra){ if(headGX>=food.x && headGX<food.x+food.w && headGY>=food.y && headGY<food.y+food.h){
      ateMain=true; totalEaten++; eatenSinceSpeedup++; scoreVar+=food.points; spawnParticlesAt(food.x,food.y,food.w,food.h,food.cat); pendingHairspray=(Math.random()<0.10); placeFood(); } }
  if(!ateMain && !ateExtra) snake.pop(); if(eatenSinceSpeedup>=3){ stepDelay=Math.max(MIN_STEP,Math.round(stepDelay*SPEED_MULT_COMBINED)); eatenSinceSpeedup=0; }
  if(extraFood && performance.now()>extraFood.expiresAt) extraFood=null; scheduleNextStep(); }
function scheduleNextStep(){ if(timerId) clearTimeout(timerId); timerId=setTimeout(performStep, stepDelay); }

function setDir(nx,ny){ if(nx===-dx && ny===-dy) return; dx=nx; dy=ny; }
addEventListener('keydown',e=>{ if(e.key==='ArrowUp') setDir(0,-1); else if(e.key==='ArrowDown') setDir(0,1); else if(e.key==='ArrowLeft') setDir(-1,0); else if(e.key==='ArrowRight') setDir(1,0); });
document.getElementById('btnUp').addEventListener('click',()=>setDir(0,-1));
document.getElementById('btnDown').addEventListener('click',()=>setDir(0,1));
document.getElementById('btnLeft').addEventListener('click',()=>setDir(-1,0));
document.getElementById('btnRight').addEventListener('click',()=>setDir(1,0));

/* ====== НАДЁЖНАЯ отправка в GAS ====== */
async function sendScoreToSheets({username, score, tg_id}){
  const json = JSON.stringify({ username, score:String(score), tg_id });

  // 1) navigator.sendBeacon (без CORS/префлайта)
  try{
    if (navigator.sendBeacon){
      const ok = navigator.sendBeacon(LB_URL, new Blob([json], { type:'text/plain;charset=UTF-8' }));
      if (ok) return {ok:true, via:'beacon'};
    }
  }catch(_){}

  // 2) no-cors + text/plain (не читаем ответ — и не нужно)
  try{
    await fetch(LB_URL, { method:'POST', mode:'no-cors', headers:{'Content-Type':'text/plain;charset=UTF-8'}, body: json });
    return {ok:true, via:'no-cors'};
  }catch(_){}

  // 3) JSON обычный (если CORS позволяет)
  try{
    const res = await fetch(LB_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: json });
    return {ok:res.ok, via:'json', status:res.status};
  }catch(e){
    return {ok:false, error:String(e)};
  }
}

/* ====== GET топа для модалки ====== */
async function getTopFromSheets(){
  const res = await fetch(LB_URL); // doGet -> { top: [...] }
  if (!res.ok) throw new Error('LB fetch failed');
  return res.json();
}

/* ====== Конец игры ====== */
async function onGameOver(){
  const score = Number(scoreVar) || 0;
  const username = getTgUsername() || 'Игрок';
  const tg_id = getTgId() || '';

  try { await sendScoreToSheets({ username, score, tg_id }); } catch(e){ console.warn('GAS send err', e); }

  btnRestart.style.display='block';
  btnShare.style.display='block';
}

/* ====== Лидерборд ====== */
const lbModal=document.getElementById('leaderboardModal'); const lbList=document.getElementById('lbList'); const lbClose=document.getElementById('lbClose');
function openLeaderboard(top=[], meName=null, myTgId=''){
  lbList.innerHTML=''; top.forEach((row,idx)=>{ const isMe=(myTgId && row.tg_id==myTgId)||(!myTgId && row.username===meName);
    const li=document.createElement('li'); if(isMe) li.className='lb-item-me';
    li.innerHTML=`<div style="display:flex;justify-content:space-between;gap:12px;"><span>#${idx+1} ${row.username||'Игрок'}${row.tg_id?' · tg:'+row.tg_id:''}</span><strong>${row.score}</strong></div>`;
    lbList.appendChild(li); });
  lbModal.hidden=false;
}
lbClose?.addEventListener('click',()=>lbModal.hidden=true);
lbModal?.addEventListener('click',e=>{ if(e.target===lbModal) lbModal.hidden=true; });

btnShare.addEventListener('click', async ()=>{
  try{ const data=await getTopFromSheets(); openLeaderboard(data.top||[], getTgUsername(), getTgId()); }
  catch(e){ alert('Не удалось загрузить таблицу :('); console.warn(e); }
});

/* ====== Старт ====== */
resizeCanvas(); initGame(); requestAnimationFrame(renderLoop);
</script>
</body>
</html>


